#!@PYTHON@ -s
#
# Copyright (c) 2010-2013 Shaun McCance <shaunm@gnome.org>
#
# ITS Tool program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# ITS Tool is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with ITS Tool; if not, write to the Free Software Foundation, 59 Temple
# Place, Suite 330, Boston, MA  0211-1307  USA.
#
from __future__ import unicode_literals

VERSION="@VERSION@"
DATADIR="@DATADIR@"

import gettext
import hashlib
import optparse
import os
import os.path
import re
import sys
import time
from copy import copy, deepcopy
from lxml import etree

NS_ITS = 'http://www.w3.org/2005/11/its'
NS_ITST = 'http://itstool.org/extensions/'
NS_BLANK = 'http://itstool.org/extensions/blank/'
NS_XLINK = 'http://www.w3.org/1999/xlink'
NS_XML = 'http://www.w3.org/XML/1998/namespace'


class ParseError(Exception):
    pass


class XMLParser(object):
    """Parser code encapsulating any libxml2 direct access."""
    def __init__(self, load_dtd=False, keep_entities=False, line_numbers=True):
        self._keep_entities = keep_entities
        self._parser = etree.XMLParser(load_dtd=load_dtd, resolve_entities=not keep_entities)
        self._doc_types = []

    def parse_file(self, filename):
        try:
            tree = etree.parse(filename, self._parser)
        except etree.XMLSyntaxError as err:
            sys.stderr.write('Error: Could not parse document:\n%s\n' % str(err))
            sys.exit(1)
        tree.xinclude()
        self.filename = filename
        rules = self.collect_rules(tree.getroot())
        return tree.getroot(), rules

    def parse_simple_file(self, filename):
        return libxml2.parseFile(filename)

    def create_node(self, content):
        try:
            return etree.fromstring(content, parser=self._parser)
        except etree.XMLSyntaxError as err:
            raise ParseError(err)

    def get_dtd(self, tree):
        """Return a serialized version of the tree document DTD."""
        if self._keep_entities and tree.docinfo.doctype:
            if tree.docinfo.internalDTD and tree.docinfo.internalDTD.entities():
                if tree not in self._doc_types:
                    # lxml doesn't provide a way to serialize only a doctype with internal defs
                    # Hack, hack hack!
                    out = etree.tostring(tree)
                    root_start = out.find('<' + tree.getroot().tag)
                    self.doc_types[tree] = out[:root_start].strip()
                return self._doc_types[tree]
            return tree.docinfo.doctype
        else:
            return ''

    def collect_rules(self, node):
        rules = []
        for child in xml_child_iter(node):
            if xml_is_ns_name(child, NS_ITS, 'rules'):
                href = child.get('{%s}href' % NS_XLINK)
                if href:
                    fileref = os.path.join(os.path.dirname(self.filename), href)
                    if not os.path.exists(fileref):
                        if opts.itspath is not None:
                            for pathdir in opts.itspath:
                                fileref = os.path.join(pathdir, href)
                                if os.path.exists(fileref):
                                    break
                    if not os.path.exists(fileref):
                        sys.stderr.write('Error: Could not locate ITS file %s\n' % href)
                        sys.exit(1)
                    root = etree.parse(fileref).getroot()
                    version = root.get('version')
                    if version is None:
                        sys.stderr.write('Warning: ITS file %s missing version attribute\n' %
                                         os.path.basename(href))
                    if version is not None and version not in ('1.0', '2.0'):
                        sys.stderr.write('Warning: Skipping ITS file %s with unknown version %s\n' %
                                         (os.path.basename(href), version))
                    else:
                        rules.append(root)
                version = child.get('version')
                if version is None:
                    root = child.getroottree().getroot()
                    version = root.get('{%s}version' % NS_ITS)
                    if version is None:
                        sys.stderr.write('Warning: Local ITS rules missing version attribute\n')
                if version is not None and version not in ('1.0', '2.0'):
                    sys.stderr.write('Warning: Skipping local ITS rules with unknown version %s\n' %
                                     version)
                else:
                    rules.append(child)
            rules.extend(self.collect_rules(child))
        return rules


class NoneTranslations:
    def gettext(self, message):
        return None

    def lgettext(self, message):
        return None

    def ngettext(self, msgid1, msgid2, n):
        return None

    def lngettext(self, msgid1, msgid2, n):
        return None

    def ugettext(self, message):
        return None

    def ungettext(self, msgid1, msgid2, n):
        return None


class MessageList (object):
    def __init__ (self):
        self._messages = []
        self._by_node = {}
        self._has_credits = False

    def add_message (self, message, node):
        self._messages.append (message)
        if node is not None:
            self._by_node[node] = message

    def add_credits(self):
        if self._has_credits:
            return
        msg = Message()
        msg.set_context('_')
        msg.add_text('translator-credits')
        msg.add_comment(Comment('Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2'))
        self._messages.append(msg)
        self._has_credits = True

    def get_message_by_node (self, node):
        return self._by_node.get(node, None)

    def get_nodes_with_messages (self):
        return self._by_node.keys()

    def output (self, out):
        msgs = []
        msgdict = {}
        for msg in self._messages:
            key = (msg.get_context(), msg.get_string())
            if msgdict.has_key(key):
                for source in msg.get_sources():
                    msgdict[key].add_source(source)
                for marker in msg.get_markers():
                    msgdict[key].add_marker(marker)
                for comment in msg.get_comments():
                    msgdict[key].add_comment(comment)
                for idvalue in msg.get_id_values():
                    msgdict[key].add_id_value(idvalue)
                if msg.get_preserve_space():
                    msgdict[key].set_preserve_space()
                if msg.get_locale_filter() is not None:
                    locale = msgdict[key].get_locale_filter()
                    if locale is not None:
                        msgdict[key].set_locale_filter('%s, %s' % (locale, msg.get_locale_filter()))
                    else:
                        msgdict[key].set_locale_filter(msg.get_locale_filter())
                
            else:
                msgs.append(msg)
                msgdict[key] = msg
        out.write('msgid ""\n')
        out.write('msgstr ""\n')
        out.write('"Project-Id-Version: PACKAGE VERSION\\n"\n')
        out.write('"POT-Creation-Date: %s\\n"\n' % time.strftime("%Y-%m-%d %H:%M%z"))
        out.write('"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"\n')
        out.write('"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"\n')
        out.write('"Language-Team: LANGUAGE <LL@li.org>\\n"\n')
        out.write('"MIME-Version: 1.0\\n"\n')
        out.write('"Content-Type: text/plain; charset=UTF-8\\n"\n')
        out.write('"Content-Transfer-Encoding: 8bit\\n"\n')
        out.write('\n')
        for msg in msgs:
            out.write(msg.format().encode('utf-8'))
            out.write('\n')


class Comment (object):
    def __init__ (self, text):
        self._text = str(text)
        assert(text is not None)
        self._markers = []

    def add_marker (self, marker):
        self._markers.append(marker)

    def get_markers (self):
        return self._markers

    def get_text (self):
        return self._text

    def format (self):
        ret = u''
        markers = {}
        for marker in self._markers:
            if not markers.has_key(marker):
                ret += '#. (itstool) comment: ' + marker + '\n'
                markers[marker] = marker
        if '\n' in self._text:
            doadd = False
            for line in self._text.split('\n'):
                if line != '':
                    doadd = True
                if not doadd:
                    continue
                ret += u'#. %s\n' % line
        else:
            text = self._text
            while len(text) > 72:
                j = text.rfind(' ', 0, 72)
                if j == -1:
                    j = text.find(' ')
                if j == -1:
                    break
                ret += u'#. %s\n' % text[:j]
                text = text[j+1:]
            ret += '#. %s\n' % text
        return ret


class Message (object):
    def __init__ (self):
        self._message = []
        self._empty = True
        self._ctxt = None
        self._placeholders = []
        self._sources = []
        self._markers = []
        self._id_values = []
        self._locale_filter = None
        self._comments = []
        self._preserve = False

    def __repr__(self):
        if self._empty:
            return "Empty message"
        return self.get_string()

    class Placeholder (object):
        def __init__ (self, node):
            self.node = node
            self.name = stripped_tag(node)

    def escape (self, text):
        return text.replace('\\','\\\\').replace('"', "\\\"").replace("\n","\\n").replace("\t","\\t")

    def add_text (self, text):
        if len(self._message) == 0 or not(isinstance(self._message[-1], basestring)):
            self._message.append('')
        if not isinstance(text, unicode):
            text = unicode(text, 'utf-8')
        self._message[-1] += text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
        if re.sub('\s+', ' ', text).strip() != '':
            self._empty = False

    def add_entity_ref (self, name):
        self._message.append('&' + name + ';')
        self._empty = False

    def add_placeholder (self, node):
        holder = Message.Placeholder(node)
        self._placeholders.append(holder)
        self._message.append(holder)

    def get_placeholder (self, name):
        placeholder = 1
        for holder in self._placeholders:
            holdername = u'%s-%i' % (holder.name, placeholder)
            if holdername == name:
                return holder
            placeholder += 1

    def add_start_tag (self, node):
        if len(self._message) == 0 or not(isinstance(self._message[-1], basestring)):
            self._message.append('')
        if node.prefix:
            tag = node.tag[node.tag.index('}') + 1:]
            self._message[-1] += (u'<%s:%s' % (unicode(node.prefix, 'utf-8'), unicode(tag, 'utf-8')))
        else:
            self._message[-1] += u'<%s' % stripped_tag(node)
        for prop in xml_attr_iter(node):
            name = prop.name
            if prop.prefix is not None:
                name = prop.prefix + ':' + name
            atval = prop.content
            if not isinstance(atval, unicode):
                atval = unicode(atval, 'utf-8')
            atval = atval.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')
            self._message += " %s=\"%s\"" % (name, atval)
        if len(list(xml_child_iter(node))):
            self._message[-1] += '>'
        else:
            self._message[-1] += '/>'

    def add_end_tag (self, node):
        if len(list(xml_child_iter(node))):
            if len(self._message) == 0 or not(isinstance(self._message[-1], basestring)):
                self._message.append('')
            if node.prefix:
                tag = node.tag[node.tag.index('}') + 1:]
                self._message[-1] += u'</%s:%s>' % (node.prefix, tag)
            else:
                self._message[-1] += u'</%s>' % stripped_tag(node)

    def is_empty (self):
        return self._empty

    def get_context (self):
        return self._ctxt

    def set_context (self, ctxt):
        self._ctxt = ctxt

    def add_source (self, source):
        if not isinstance(source, unicode):
            source = unicode(source, 'utf-8')
        self._sources.append(source)

    def get_sources (self):
        return self._sources

    def add_marker (self, marker):
        if not isinstance(marker, unicode):
            marker = unicode(marker, 'utf-8')
        self._markers.append(marker)

    def get_markers (self):
        return self._markers

    def add_id_value(self, id_value):
        self._id_values.append(id_value)

    def get_id_values(self):
        return self._id_values

    def add_comment (self, comment):
        if comment is not None:
            self._comments.append(comment)

    def get_comments (self):
        return self._comments

    def get_string (self):
        message = u''
        placeholder = 1
        for msg in self._message:
            if isinstance(msg, basestring):
                message += msg
            elif isinstance(msg, Message.Placeholder):
                message += u'<_:%s-%i/>' % (msg.name, placeholder)
                placeholder += 1
        if not self._preserve:
            message = re.sub('\s+', ' ', message).strip()
        return message

    def get_preserve_space (self):
        return self._preserve

    def set_preserve_space (self, preserve=True):
        self._preserve = preserve

    def get_locale_filter(self):
        return self._locale_filter

    def set_locale_filter(self, locale):
        self._locale_filter = locale

    def format (self):
        ret = u''
        markers = {}
        for marker in self._markers:
            if not markers.has_key(marker):
                ret += '#. (itstool) path: ' + marker + '\n'
                markers[marker] = marker
        for idvalue in self._id_values:
            ret += '#. (itstool) id: ' + idvalue + '\n'
        if self._locale_filter is not None:
            ret += '#. (itstool) ' + self._locale_filter[1] + ' locale: ' + self._locale_filter[0] + '\n'
        comments = []
        commentsdict = {}
        for comment in self._comments:
            key = comment.get_text()
            if commentsdict.has_key(key):
                for marker in comment.get_markers():
                    commentsdict[key].add_marker(marker)
            else:
                comments.append(comment)
                commentsdict[key] = comment
        for i in range(len(comments)):
            if i != 0:
                ret += '#.\n'
            ret += comments[i].format()
        for source in self._sources:
            ret += u'#: %s\n' % source
        if self._preserve:
            ret += u'#, no-wrap\n'
        if self._ctxt is not None:
            ret += u'msgctxt "%s"\n' % self._ctxt
        message = self.get_string()
        if self._preserve:
            ret += u'msgid ""\n'
            lines = message.split('\n')
            for line, no in zip(lines, range(len(lines))):
                if no == len(lines) - 1:
                    ret += u'"%s"\n' % self.escape(line)
                else:
                    ret += u'"%s\\n"\n' % self.escape(line)
        else:
            ret += u'msgid "%s"\n' % self.escape(message)
        ret += u'msgstr ""\n'
        return ret


class TextNode(object):
    type = 'text'
    def __init__(self, content):
        self.content = content

    def __repr__(self):
        return "<TextNode: %s>" % self.content if len(self.content) < 10 else (self.content[:8] + "...")

    def is_blank(self):
        return re.sub('\s+', '', self.content) == ''


class XMLNs(object):
    def __init__(self, name, content):
        self.name = name
        self.content = content


class XMLAttr(object):
    def __init__(self, attr):
        self.key = attr.attrname
        self.content = attr

    def __repr__(self):
        return "<XMLAttr: %s for %s>" % (self.key, self.content.getparent())

    # Defining __hash__ and __eq__ allow XMLAttr to be used as a dictionary key
    def __hash__(self):
        return hash(unicode(self.content.getparent()) + self.key)

    def __eq__(self, other):
        return self.content.getparent() == other.content.getparent() and self.key == other.key

    @property
    def name(self):
        return self.key[self.key.find('}') + 1:] if '}' in self.key else self.key

    @property
    def prefix(self):
        if '}' in self.key:
            ns_url = self.key[1:self.key.index('}')]
            if ns_url == NS_XML:
                return 'xml'
            else:
                return {v: k for k, v in self.content.getparent().nsmap.items()}[ns_url]
        else:
            return None

    # Match the Element API
    def get(self, key):
        return None

    def keys(self):
        return []

    def getparent(self):
        return self.content.getparent()

    @property
    def sourceline(self):
        return self.content.getparent().sourceline


def xml_type(node):
    if hasattr(node, 'tag'):
        if isinstance(node, etree._Entity):
            return 'entity_ref'
        return 'element'
    elif isinstance(node, TextNode):
        return 'text'
    elif isinstance(node, XMLAttr):
        return 'attribute'
    else:
        return 'unknown'

def stripped_tag(node):
    """Strip the ns prefix of a node tag, if any."""
    return node.tag[node.tag.index('}') + 1:] if '}' in node.tag else node.tag

def xml_child_iter (node):
    """
    Similar to node.xpath("child::node()") but also producing nodes for entities.
    """
    if xml_type(node) not in ('element', 'entity'):
        raise StopIteration
    if node.text:
        yield TextNode(node.text)
    for child in node.iterchildren():
        yield child
        if child.tail:
            yield TextNode(child.tail)

def xml_attr_iter (node):
    for attr in node.xpath('./@*'):
        yield XMLAttr(attr)

def xml_is_ns_name (node, ns, name):
    if xml_type(node) != 'element':
        return False
    return node.tag == '{%s}%s' % (ns, name)

def xml_get_node_path(node):
    # The built-in nodePath() method only does numeric indexes
    # when necessary for disambiguation. For various reasons,
    # we prefer always using indexes.
    prefix = '%s:' % node.prefix if node.prefix else ''
    if xml_type(node) == 'attribute':
        name = '/@%s%s' % (prefix, node.name)
    else:
        name = '/%s%s' % (prefix, stripped_tag(node))
    if xml_type(node) == 'element' and xml_type(node.getparent()) == 'element':
        count = 1
        prev = node.getprevious()
        while prev is not None:
            if prev.tag == node.tag:
                if prev.prefix is None:
                    if node.prefix is None:
                        count += 1
                else:
                    if node.prefix is not None:
                        if prev.prefix == node.prefix:
                            count += 1
            prev = prev.getprevious()
        name = '%s[%i]' % (name, count)
    if xml_type(node.getparent()) == 'element':
        name = xml_get_node_path(node.getparent()) + name
    return name

def fix_node_ns (node, nsdefs):
    # FIXME evaluate etree.cleanup_namespaces()
    childnsdefs = nsdefs.copy()
    for key, nsdef in node.nsmap.items():
        if key in nsdefs and nsdefs[key] == nsdef:
            del node.nsmap[key]
        else:
            childnsdefs[key] = nsdef
    for child in xml_child_iter(node):
        if xml_type(child) == 'element':
            fix_node_ns(child, childnsdefs)


class LocNote (object):
    def __init__(self, locnote=None, locnoteref=None, locnotetype=None, space=False):
        self.locnote = locnote
        self.locnoteref = locnoteref
        self.locnotetype = locnotetype
        if self.locnotetype != 'alert':
            self.locnotetype = 'description'
        self._preserve_space=space

    def __repr__(self):
        if self.locnote is not None:
            if self._preserve_space:
                return self.locnote
            else:
                return re.sub('\s+', ' ', self.locnote).strip()
        elif self.locnoteref is not None:
            return '(itstool) link: ' + re.sub('\s+', ' ', self.locnoteref).strip()
        return ''


class Document (object):
    def __init__ (self, filename, messages, load_dtd=False, keep_entities=False):
        self._filename = filename
        self._msgs = messages
        self._load_dtd = load_dtd
        self._keep_entities = keep_entities

        self.parser = XMLParser(load_dtd=load_dtd, keep_entities=keep_entities)
        self._doc, self._localrules = self.parser.parse_file(filename)
        self._doc_name = filename
        self._its_translate_nodes = {}
        self._its_within_text_nodes = {}
        self._its_locale_filters = {}
        self._its_id_values = {}
        self._its_loc_notes = {}
        self._its_preserve_space_nodes = {}
        self._itst_drop_nodes = {}
        self._itst_contexts = {}
        self._its_lang = {}
        self._itst_lang_attr = {}
        self._itst_credits = None
        self._its_externals = {}

    def register_its_params(self, xpath, rules, params={}):
        for child in xml_child_iter(rules):
            if xml_is_ns_name(child, NS_ITS, 'param'):
                name = child.get('name')
                if params.has_key(name):
                    value = params[name]
                else:
                    value = child.getContent()
                xpath.xpathRegisterVariable(name, None, value)

    def apply_its_rule(self, rule, xpath):
        if xml_type(rule) != 'element':
            return
        selector = rule.get('selector')
        if xml_is_ns_name(rule, NS_ITS, 'translateRule'):
            if selector is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    self._its_translate_nodes[node] = rule.get('translate')
        elif xml_is_ns_name(rule, NS_ITS, 'withinTextRule'):
            if selector is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    self._its_within_text_nodes[node] = rule.get('withinText')
        elif xml_is_ns_name(rule, NS_ITST, 'preserveSpaceRule'):
            if selector is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    val = rule.get('preserveSpace')
                    if val == 'yes':
                        self._its_preserve_space_nodes[node] = 'preserve'
        elif xml_is_ns_name(rule, NS_ITS, 'preserveSpaceRule'):
            if selector is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    self._its_preserve_space_nodes[node] = rule.get('space')
        elif xml_is_ns_name(rule, NS_ITS, 'localeFilterRule'):
            if selector is not None:
                lst = rule.get('localeFilterList', '*')
                typ = rule.get('localeFilterType', 'include')
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    self._its_locale_filters[node] = (lst, typ)
        elif xml_is_ns_name(rule, NS_ITST, 'dropRule'):
            if selector is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    self._itst_drop_nodes[node] = rule.get('drop')
        elif xml_is_ns_name(rule, NS_ITS, 'idValueRule'):
            idv = rule.get('idValue')
            if selector is not None and idv is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    idvalue = node.xpath(idv)
                    if isinstance(idvalue, basestring):
                        self._its_id_values[node] = idvalue
                    else:
                        for val in idvalue:
                            self._its_id_values[node] = val.content
                            break
        elif xml_is_ns_name(rule, NS_ITST, 'contextRule'):
            if selector is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    if rule.get('context'):
                        self._itst_contexts[node] = rule.get('context')
                    elif rule.get('contextPointer'):
                        ctxts = node.xpath(rule.get('contextPointer'))
                        if isinstance(ctxts, basestring):
                            self._itst_contexts[node] = ctxts
                        else:
                            for ctxt in ctxts:
                                self._itst_contexts[node] = ctxt
                                break
        elif xml_is_ns_name(rule, NS_ITS, 'locNoteRule'):
            locnote = None
            notetype = rule.get('locNoteType')
            for child in xml_child_iter(rule):
                if xml_is_ns_name(child, NS_ITS, 'locNote'):
                    locnote = LocNote(locnote=child.xpath('string()'), locnotetype=notetype)
                    break
            if locnote is None:
                if rule.get('locNoteRef'):
                    locnote = LocNote(locnoteref=rule.get('locNoteRef'), locnotetype=notetype)
            if selector is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    if locnote is not None:
                        self._its_loc_notes.setdefault(node, []).append(locnote)
                    else:
                        if rule.get('locNotePointer'):
                            sel = rule.get('locNotePointer')
                            ref = False
                        elif rule.get('locNoteRefPointer'):
                            sel = rule.get('locNoteRefPointer')
                            ref = True
                        else:
                            continue
                        notes = node.xpath(sel)
                        for note in notes:
                            text = note if isinstance(note, basestring) else note.text
                            if ref:
                                nodenote = LocNote(locnoteref=text, locnotetype=notetype)
                            else:
                                nodenote = LocNote(locnote=text, locnotetype=notetype,
                                                   space=self.get_preserve_space(note))
                            self._its_loc_notes.setdefault(node, []).append(nodenote)
        elif xml_is_ns_name(rule, NS_ITS, 'langRule'):
            if selector is not None and rule.get('langPointer') is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    try:
                        oldnode = xpath.contextNode()
                    except:
                        oldnode = None
                    xpath.setContextNode(node)
                    res = self._try_xpath_eval(xpath, rule.get('langPointer'))
                    if len(res) > 0:
                        self._its_lang[node] = res[0].content
                    # We need to construct language attributes, not just read
                    # language information. Technically, langPointer could be
                    # any XPath expression. But if it looks like an attribute
                    # accessor, just use the attribute name.
                    if rule.get('langPointer')[0] == '@':
                        self._itst_lang_attr[node] = rule.get('langPointer')[1:]
                    xpath.setContextNode(oldnode)
        elif xml_is_ns_name(rule, NS_ITST, 'credits'):
            if rule.get('appendTo') is not None:
                for node in self._try_xpath_eval(xpath, rule.get('appendTo'), rule.nsmap):
                    self._itst_credits = (node, rule)
                    break
        elif (xml_is_ns_name(rule, NS_ITS, 'externalResourceRefRule') or
              xml_is_ns_name(rule, NS_ITST, 'externalRefRule')):
            if xml_is_ns_name(rule, NS_ITS, 'externalResourceRefRule'):
                ptr = rule.get('externalResourceRefPointer')
            else:
                ptr = rule.get('refPointer')
            if selector is not None and ptr is not None:
                for node in self._try_xpath_eval(xpath, selector, rule.nsmap):
                    ext_value = None
                    if isinstance(node, basestring):
                        ext_value = node
                    elif isinstance(node, XMLAttr):
                        ext_value = node.content
                    else:
                        res = node.xpath(ptr)
                        if len(res) > 0:
                            ext_value = res[0] if isinstance(res[0], basestring) else res[0].text
                    if ext_value is not None:
                        self._its_externals[node] = ext_value

    def apply_its_rules(self, builtins, params={}):
        if builtins:
            dirs = []
            ddir = os.getenv('XDG_DATA_HOME', '')
            if ddir == '':
                ddir = os.path.join(os.path.expanduser('~'), '.local', 'share')
            dirs.append(ddir)
            ddir = os.getenv('XDG_DATA_DIRS', '')
            if ddir == '':
                if DATADIR not in ('/usr/local/share', '/usr/share'):
                    ddir += DATADIR + ':'
                ddir += '/usr/local/share:/usr/share'
            dirs.extend(ddir.split(':'))
            ddone = {}
            for ddir in dirs:
                itsdir = os.path.join(ddir, 'itstool', 'its')
                if not os.path.exists(itsdir):
                    continue
                for dfile in os.listdir(itsdir):
                    if dfile.endswith('.its'):
                        if not ddone.get(dfile, False):
                            self.apply_its_file(os.path.join(itsdir, dfile), params=params)
                            ddone[dfile] = True
        self.apply_local_its_rules(params=params)

    def apply_its_file(self, filename, params={}):
        doc = self.parser.parse_simple_file(filename)
        root = doc.getRootElement()
        if not xml_is_ns_name(root, NS_ITS, 'rules'):
            return
        version = root.get('version')
        if version is None:
            sys.stderr.write('Warning: ITS file %s missing version attribute\n' %
                             os.path.basename(filename))
        if version is not None and version not in ('1.0', '2.0'):
            sys.stderr.write('Warning: Skipping ITS file %s with unknown version %s\n' %
                             (os.path.basename(filename), version))
            return
        matched = True
        for match in xml_child_iter(root):
            if xml_is_ns_name(match, NS_ITST, 'match'):
                matched = False
                xpath = self._doc.xpathNewContext()
                par = match
                nss = {}
                while par is not None:
                    nsdef = par.nsDefs()
                    while nsdef is not None:
                        if nsdef.name is not None:
                            if not nss.has_key(nsdef.name):
                                nss[nsdef.name] = nsdef.content
                                xpath.xpathRegisterNs(nsdef.name, nsdef.content)
                        nsdef = nsdef.next
                    par = par.getparent()
                if match.get('selector'):
                    if len(self._try_xpath_eval(xpath, match.get('selector'))) > 0:
                        matched = True
                        break
        if matched == False:
            return
        for rule in xml_child_iter(root):
            xpath = self._doc.xpathNewContext()
            par = match
            nss = {}
            while par is not None:
                nsdef = par.nsDefs()
                while nsdef is not None:
                    if nsdef.name is not None:
                        if not nss.has_key(nsdef.name):
                            nss[nsdef.name] = nsdef.content
                            xpath.xpathRegisterNs(nsdef.name, nsdef.content)
                    nsdef = nsdef.next
                par = par.getparent()
            self.register_its_params(xpath, root, params=params)
            self.apply_its_rule(rule, xpath)

    def apply_local_its_rules(self, params={}):
        for rules in self._localrules:
            def reg_ns(xpath, node):
                if node.getparent() is not None:
                    reg_ns(xpath, node.getparent())
                nsdef = node.nsDefs()
                while nsdef is not None:
                    if nsdef.name is not None:
                        xpath.xpathRegisterNs(nsdef.name, nsdef.content)
                    nsdef = nsdef.next
            #xpath = self._doc.xpathNewContext()
            #reg_ns(xpath, rules)
            #self.register_its_params(xpath, rules, params=params)
            for rule in xml_child_iter(rules):
                if xml_type(rule) != 'element':
                    continue
                #if rule.nsDefs() is not None:
                #    rule_xpath = self._doc.xpathNewContext()
                #    reg_ns(rule_xpath, rule)
                #    self.register_its_params(rule_xpath, rules, params=params)
                #else:
                #    rule_xpath = xpath
                #self.apply_its_rule(rule, rule_xpath)
                self.apply_its_rule(rule, None)

    def _append_credits(self, parent, node, trdata):
        if xml_is_ns_name(node, NS_ITST, 'for-each'):
            select = node.get('select')
            if select == 'years':
                for year in trdata[2].split(','):
                    for child in xml_child_iter(node):
                        self._append_credits(parent, child, trdata + (year.strip(),))
        elif xml_is_ns_name(node, NS_ITST, 'value-of'):
            select = node.get('select')
            val = None
            if select == 'name':
                val = trdata[0]
            elif select == 'email':
                val = trdata[1]
            elif select == 'years':
                val = trdata[2]
            elif select == 'year' and len(trdata) == 4:
                val = trdata[3]
            if val is not None:
                val = val.encode('utf-8')
                parent.addContent(val)
        else:
            newnode = node.copyNode(2)
            parent.addChild(newnode)
            for child in xml_child_iter(node):
                self._append_credits(newnode, child, trdata)

    def merge_credits(self, translations, language, node):
        if self._itst_credits is None:
            return
        # Dear Python, please implement pgettext.
        # http://bugs.python.org/issue2504
        # Sincerely, Shaun
        trans = translations.ugettext('_\x04translator-credits')
        if trans is None or trans == 'translator-credits':
            return
        regex = re.compile('(.*) \<(.*)\>, (.*)')
        for credit in trans.split('\n'):
            match = regex.match(credit)
            if not match:
                continue
            trdata = match.groups()
            for node in xml_child_iter(self._itst_credits[1]):
                self._append_credits(self._itst_credits[0], node, trdata)

    def join_translations(self, translations, strict=False):
        self.generate_messages(comments=False)
        self._join_translations(translations, self._doc, None, strict=strict)
        # Because of the way we create nodes and rewrite the document,
        # we end up with lots of redundant namespace definitions. We
        # kill them off in one fell swoop at the end.
        fix_node_ns(self._doc, {})

    def _join_translations(self, translations, node, previous, strict=False):
        if xml_type(node) != 'element':
            return
        if self.get_itst_drop(node) == 'yes':
            node.unlinkNode()
            node.freeNode()
            if previous is not None and previous.isBlankNode():
                previous.unlinkNode()
                previous.freeNode()
            return
        msg = self._msgs.get_message_by_node(node)
        if msg is None:
            self.translate_attrs(node, node)
            children = [child for child in xml_child_iter(node)]
            prev_node = None
            for child in children:
                self._join_translations(translations, child, prev_node, strict=strict)
                prev_node = child
        else:
            current_tail = None
            if previous is not None and xml_type(previous) == 'text' and previous.is_blank():
                current_tail = previous.content
            end_tail = node.tail
            parent_node = node.getparent()
            current_index = node.getparent().index(node)
            for lang in sorted(translations.keys()):
                locale = self.get_its_locale_filter(node)
                lmatch = match_locale_list(locale[0], lang)
                if (locale[1] == 'include' and not lmatch) or (locale[1] == 'exclude' and lmatch):
                    continue
                newnode = self.get_translated(node, translations[lang], strict=strict, lang=lang)
                if newnode != node:
                    newnode.set('{%s}lang' % NS_XML, lang)
                    parent_node.insert(current_index + 1, newnode)
                    current_index += 1
                    if current_tail:
                        newnode.tail = current_tail
                        node.tail = current_tail
            newnode.tail = end_tail

    def merge_translations(self, translations, language, strict=False):
        self.generate_messages(comments=False)
        self.merge_credits(translations, language, self._doc)
        self._merge_translations(translations, language, self._doc, strict=strict)
        # Apply language attributes to untranslated nodes. We don't do
        # this before processing, because then these attributes would
        # be copied into the new nodes. We apply the attribute without
        # checking whether it was translated, because any that were will
        # just be floating around, unattached to a document.
        for lcnode in self._msgs.get_nodes_with_messages():
            attr = self._itst_lang_attr.get(lcnode)
            if attr is None:
                continue
            origlang = None
            lcpar = lcnode
            while lcpar is not None:
                origlang = self._its_lang.get(lcpar)
                if origlang is not None:
                    break
                lcpar = lcpar.getparent()
            if origlang is not None:
                lcnode.setProp(attr, origlang)
        # And then set the language attribute on the root node.
        if language is not None:
            attr = self._itst_lang_attr.get(self._doc)
            if attr is not None:
                self._doc.setProp(attr, language)
        # Because of the way we create nodes and rewrite the document,
        # we end up with lots of redundant namespace definitions. We
        # kill them off in one fell swoop at the end.
        fix_node_ns(self._doc, {})

    def _should_drop_node(self, node, language):
        if self.get_itst_drop(node) == 'yes':
            return True
        locale = self.get_its_locale_filter(node)
        if locale[1] == 'include' and locale[0] != '*' and not match_locale_list(locale[0], language):
            return True
        elif locale[1] == 'exclude' and match_locale_list(locale[0], language):
            return True
        return False

    def _merge_translations(self, translations, language, node, strict=False):
        if xml_type(node) != 'element':
            return
        if self._should_drop_node(node, language):
            node_tail = node.tail
            node_parent = node.getparent()
            previous = node.getprevious()
            if previous is not None:
                previous.tail = node_tail
            node_parent.remove(node)
            if len(node_parent.getchildren()) == 0:
                node_parent.text = node_tail
            return
        msg = self._msgs.get_message_by_node(node)
        if msg is None:
            self.translate_attrs(node, node)
            children = [child for child in xml_child_iter(node)]
            for child in children:
                new_node = self._merge_translations(translations, language, node=child, strict=strict)
                if new_node is not None and new_node != child:
                    self.translate_attrs(child, new_node)
                    node.replace(child, new_node)
            return node
        else:
            return self.get_translated(node, translations, strict=strict, lang=language)

    def translate_attrs(self, oldnode, newnode):
        trans_attrs = [attr for attr in xml_attr_iter(oldnode) if self._its_translate_nodes.get(attr, 'no') == 'yes']
        for attr in trans_attrs:
            newcontent = translations.ugettext(attr.content)
            if newcontent:
                newnode.set(attr.name, newcontent)

    def get_translated (self, node, translations, strict=False, lang=None):
        msg = self._msgs.get_message_by_node(node)
        if msg is None:
            return node
        msgstr = msg.get_string()
        # Dear Python, please implement pgettext.
        # http://bugs.python.org/issue2504
        # Sincerely, Shaun
        if msg.get_context() is not None:
            msgstr = msg.get_context() + '\x04' + msgstr
        trans = translations.ugettext(msgstr)
        if trans is None:
            return node
        nss = {'_': NS_BLANK}
        nss.update(node.nsmap)
        blurb = self.parser.get_dtd(self._doc.getroottree())
        prefixed_tag = '%s:%s' % (node.prefix, stripped_tag(node)) if node.prefix else stripped_tag(node)
        blurb += '<' + prefixed_tag
        for key, content in nss.items():
            if key is None:
                blurb += ' xmlns="%s"' % content
            else:
                blurb += ' xmlns:%s="%s"' % (key, content)
        blurb += '>%s</%s>' % (trans, prefixed_tag)
        try:
            trnode = self.parser.create_node(blurb)
        except ParseError as e:
            if strict:
                raise
            else:
                sys.stderr.write('Warning: Could not merge %stranslation for msgid:\n%s\n' % (
                        (lang + ' ') if lang is not None else '',
                        msgstr.encode('utf-8')))
                return node

        def scan_node(node):
            children = [child for child in xml_child_iter(node)]
            for child in children:
                if xml_type(child) != 'element':
                    continue
                if child.prefix and child.nsmap[child.prefix] == NS_BLANK:
                    ph_node = msg.get_placeholder(stripped_tag(child)).node
                    if self.has_child_elements(ph_node):
                        new_node = self._merge_translations(translations, None, ph_node, strict=strict)
                        if new_node is not None and new_node != child:
                            new_node.tail = child.tail
                            node.replace(child, new_node)
                    else:
                        repl = self.get_translated(ph_node, translations, strict=strict, lang=lang)
                        node.replace(child, repl)
                scan_node(child)

        try:
            scan_node(trnode)
        except Exception:
            if strict:
                raise
            else:
                sys.stderr.write(('Warning: Could not merge %stranslation for msgid:\n%s\n' % (
                    (lang + ' ') if lang is not None else '',
                    msgstr)).encode('utf-8'))
                return node

        retnode = copy(node)  # Shallow copy
        retnode.clear()
        retnode.text = trnode.text
        retnode.tail = node.tail
        for key in node.keys():
            if key not in retnode.keys():
                retnode.set(key, node.get(key))
        for child in xml_child_iter(trnode):
            if xml_type(child)  == 'element':
                retnode.append(child) #deepcopy(child))
            elif xml_type(child) == 'entity_ref':
                retnode.append(copy(child))  # Tend to randomly segfault without the copy
        return retnode

    def generate_messages(self, comments=True):
        if self._itst_credits is not None:
            self._msgs.add_credits()
        for child in xml_child_iter(self._doc):
            if xml_type(child) == 'element':
                self.generate_message(child, None, comments=comments)

    def generate_message (self, node, msg, comments=True, path=None):
        if xml_type(node) in ('text', 'cdata') and msg is not None:
            msg.add_text(node.content)
            return
        if xml_type(node) == 'entity_ref':
            msg.add_entity_ref(node.name);
        if xml_type(node) != 'element':
            return
        if node.get('{%s}drop' % NS_ITST) == 'yes':
            return
        if self._itst_drop_nodes.get(node, 'no') == 'yes':
            return
        locfil = self.get_its_locale_filter(node)
        if locfil == ('', 'include') or locfil == ('*', 'exclude'):
            return
        if path is None:
            path = ''
        translate = self.get_its_translate(node)
        withinText = False
        parent_name = stripped_tag(node.getparent()) if node.getparent() is not None else ''
        if translate == 'no':
            if msg is not None:
                msg.add_placeholder(node)
            is_unit = False
            msg = None
        else:
            is_unit = msg is None or self.is_translation_unit(node)
            if is_unit:
                if msg is not None:
                    msg.add_placeholder(node)
                msg = Message()
                ctxt = None
                if node.get('{%s}context' % NS_ITST):
                    ctxt = node.get('{%s}context' % NS_ITST)
                if ctxt is None:
                    ctxt = self._itst_contexts.get(node)
                if ctxt is not None:
                    msg.set_context(ctxt)
                idvalue = self.get_its_id_value(node)
                if idvalue is not None:
                    basename = os.path.basename(self._filename)
                    msg.add_id_value(basename + '#' + idvalue)
                if self.get_preserve_space(node):
                    msg.set_preserve_space()
                if self.get_its_locale_filter(node) != ('*', 'include'):
                    msg.set_locale_filter(self.get_its_locale_filter(node))
                msg.add_source('%s:%i' % (self._doc_name, node.sourceline))
                msg.add_marker('%s/%s' % (parent_name, stripped_tag(node)))
            else:
                withinText = True
                msg.add_start_tag(node)

        if not withinText:
            # Add msg for translatable node attributes
            for attr in xml_attr_iter(node):
                if self._its_translate_nodes.get(attr, 'no') == 'yes':
                    attr_msg = Message()
                    attr_msg.add_source('%s:%i' % (self._doc_name, node.sourceline))
                    attr_msg.add_marker('%s/%s@%s' % (parent_name, stripped_tag(node), attr.name))
                    attr_msg.add_text(attr.content)
                    if comments:
                        for locnote in self.get_its_loc_notes(attr):
                            comment = Comment(locnote)
                            comment.add_marker ('%s/%s@%s' % (
                                    parent_name, node.name, attr.name))
                            attr_msg.add_comment(comment)
                    self._msgs.add_message(attr_msg, attr)

        if comments and msg is not None:
            cnode = node
            while cnode is not None:
                hasnote = False
                for locnote in self.get_its_loc_notes(cnode, inherit=(not withinText)):
                    comment = Comment(locnote)
                    if withinText:
                        comment.add_marker('.%s/%s' % (path, stripped_tag(cnode)))
                    msg.add_comment(comment)
                    hasnote = True
                if hasnote or not is_unit:
                    break
                cnode = cnode.getparent()

        self.generate_external_resource_message(node)
        for attr in xml_attr_iter(node):
            self.generate_external_resource_message(attr)
            idvalue = self.get_its_id_value(attr)
            if idvalue is not None:
                basename = os.path.basename(self._filename)
                msg.add_id_value(basename + '#' + idvalue)

        if withinText:
            path = path + '/' + stripped_tag(node)
        for child in xml_child_iter(node):
            self.generate_message(child, msg, comments=comments, path=path)

        if translate:
            if is_unit and not msg.is_empty():
                self._msgs.add_message(msg, node)
            elif msg is not None:
                msg.add_end_tag(node)

    def generate_external_resource_message(self, node):
        if not self._its_externals.has_key(node):
            return
        resref = self._its_externals[node]
        if xml_type(node) == 'element':
            translate = self.get_its_translate(node)
            marker = '%s/%s' % (stripped_tag(node.getparent()), stripped_tag(node))
        else:
            translate = self.get_its_translate(node.getparent())
            marker = '%s/%s/@%s' % (
                stripped_tag(node.getparent().getparent()), stripped_tag(node.getparent()), node.name)
        if translate == 'no':
            return
        msg = Message()
        try:
            fullfile = os.path.join(os.path.dirname(self._filename), resref)
            filefp = open(fullfile)
            filemd5 = hashlib.md5(filefp.read()).hexdigest()
            filefp.close()
        except:
            filemd5 = '__failed__'
        txt = "external ref='%s' md5='%s'" % (resref, filemd5)
        msg.set_context('_')
        msg.add_text(txt)
        msg.add_source('%s:%i' % (self._filename, node.sourceline))
        msg.add_marker(marker)
        msg.add_comment(Comment('This is a reference to an external file such as an image or'
                                ' video. When the file changes, the md5 hash will change to'
                                ' let you know you need to update your localized copy. The'
                                ' msgstr is not used at all. Set it to whatever you like'
                                ' once you have updated your copy of the file.'))
        self._msgs.add_message(msg, None)

    def is_translation_unit (self, node):
        return self.get_its_within_text(node) != 'yes'

    def has_child_elements(self, node):
        return len([child for child in xml_child_iter(node)])

    def get_preserve_space (self, node):
        while node is not None and xml_type(node) in ('attribute', 'element'):
            if node.get('{%s}space' % NS_XML) == 'preserve':
                return True
            if self._its_preserve_space_nodes.has_key(node):
                return (self._its_preserve_space_nodes[node] == 'preserve')
            node = node.getparent()
        return False

    def get_its_translate(self, node):
        val = None
        
        if '{%s}translate' % NS_ITS in node.keys():
            val = node.get('{%s}translate' % NS_ITS)
        elif xml_is_ns_name(node, NS_ITS, 'span') and 'translate' in node.keys():
            val = node.get('translate')
        elif node in self._its_translate_nodes:
            val = self._its_translate_nodes[node]
        if val is not None:
            return val
        if xml_type(node) == 'attribute':
            return 'no'
        parent = node.getparent()
        if parent is not None and xml_type(parent) == 'element':
            return self.get_its_translate(parent)
        return 'yes'

    def get_its_within_text(self, node):
        if '{%s}withinText' % NS_ITS in node.keys():
            val = node.get('{%s}withinText' % NS_ITS)
        elif xml_is_ns_name(node, NS_ITS, 'span') and node.get('withinText'):
            val = node.get('withinText')
        else:
            return self._its_within_text_nodes.get(node, 'no')
        if val in ('yes', 'nested'):
            return val
        return 'no'

    def get_its_locale_filter(self, node):
        if (node.get('{%s}localeFilterList' % NS_ITS) is not None or
                node.get('{%s}localeFilterType' % NS_ITS) is not None):
            lst = node.get('{%s}localeFilterList' % NS_ITS, '*')
            typ = node.get('{%s}localeFilterType' % NS_ITS, 'include')
            return (lst, typ)
        if (xml_is_ns_name(node, NS_ITS, 'span') and 
                (node.get('localeFilterList') is not None or node.get('localeFilterType') is not None)):
            lst = node.get('localeFilterList', '*')
            typ = node.get('localeFilterType', 'include')
            return (lst, typ)
        if node in self._its_locale_filters:
            return self._its_locale_filters[node]
        parent = node.getparent()
        if parent is not None and xml_type(parent) == 'element':
            return self.get_its_locale_filter(parent)
        return ('*', 'include')

    def get_itst_drop(self, node):
        if node.get('{%s}drop' % NS_ITST) == 'yes':
            return 'yes'
        if self._itst_drop_nodes.get(node, 'no') == 'yes':
            return 'yes'
        return 'no'

    def get_its_id_value(self, node):
        if xml_type(node) == 'element' and node.get('{%s}id' % NS_XML):
            return node.get('{%s}id' % NS_XML)
        return self._its_id_values.get(node, None)

    def get_its_loc_notes(self, node, inherit=True):
        ret = []
        loc_note_its = node.get('{%s}locNote' % NS_ITS)
        note_type_its = node.get('{%s}locNoteType' % NS_ITS)
        note_ref_its = node.get('{%s}locNoteRef' % NS_ITS)
        if loc_note_its or note_type_its or note_ref_its:
            if loc_note_its:
                ret.append(LocNote(locnote=loc_note_its, locnotetype=note_type_its))
            elif note_ref_its:
                ret.append(LocNote(locnoteref=note_ref_its, locnotetype=note_type_its))
        elif xml_is_ns_name(node, NS_ITS, 'span'):
            loc_note = node.get('locNote')
            note_type = node.get('locNoteType')
            note_ref = node.get('locNoteRef')
            if loc_note or note_ref or note_type:
                if loc_note:
                    ret.append(LocNote(locnote=loc_note, locnotetype=note_type))
                elif note_ref:
                    ret.append(LocNote(locnoteref=note_ref, locnotetype=note_type))
        for locnote in reversed(self._its_loc_notes.get(node, [])):
            ret.append(locnote)
        if (len(ret) == 0 and inherit and
            xml_type(node) != 'attribute' and node.getparent() is not None):
            return self.get_its_loc_notes(node.getparent())
        return ret

    def output_test_data(self, category, out, node=None):
        if node is None:
            node = self._doc
        compval = ''
        if category == 'translate':
            compval = 'translate="%s"' % self.get_its_translate(node)
        elif category == 'withinText':
            if xml_type(node) != 'attribute':
                compval = 'withinText="%s"' % self.get_its_within_text(node)
        elif category == 'localeFilter':
            compval = 'localeFilterList="%s"\tlocaleFilterType="%s"' % self.get_its_locale_filter(node)
        elif category == 'locNote':
            val = self.get_its_loc_notes(node)
            if len(val) > 0:
                if val[0].locnote is not None:
                    compval = 'locNote="%s"\tlocNoteType="%s"' % (str(val[0]), val[0].locnotetype)
                elif val[0].locnoteref is not None:
                    compval = 'locNoteRef="%s"\tlocNoteType="%s"' % (val[0].locnoteref, val[0].locnotetype)
        elif category == 'externalResourceRef':
            val = self._its_externals.get(node, '')
            if val != '':
                compval = 'externalResourceRef="%s"' % val
        elif category == 'idValue':
            val = self.get_its_id_value(node)
            if val is not None:
                compval = 'idValue="%s"' % val
        elif category == 'preserveSpace':
            if self.get_preserve_space(node):
                compval = 'space="preserve"'
            else:
                compval = 'space="default"'
        else:
            sys.stderr.write('Error: Unrecognized category %s\n' % category)
            sys.exit(1)
        if compval != '':
            out.write('%s\t%s\r\n' % (xml_get_node_path(node), compval))
        else:
            out.write('%s\r\n' % (xml_get_node_path(node)))
        if xml_type(node) != 'attribute':
            for attr in sorted(xml_attr_iter(node), lambda x, y: cmp(str(x), str(y))):
                self.output_test_data(category, out, attr)
        for child in xml_child_iter(node):
            if xml_type(child) == 'element':
                self.output_test_data(category, out, child)

    def write(self, out):
        self._doc.getroottree().write(out, encoding='utf-8', xml_declaration=True)
        out.write('\n')  # lxml doesn't write a final newline

    #@staticmethod
    def _try_xpath_eval (self, xpath, expr, extra_ns=None):
        namespaces = {k: v for k, v in self._doc.nsmap.items() if k is not None}
        if extra_ns:
            namespaces.update({k: v for k, v in extra_ns.items() if k is not None})
        try:
            return [
                XMLAttr(res) if getattr(res, 'is_attribute', False) else res
                for res in self._doc.xpath(expr, namespaces=namespaces)
            ]
        except Exception as err:
            return []
        #try:
        #    return xpath.xpathEval(expr)
        #except:
        #    sys.stderr.write('Warning: Invalid XPath: %s\n' % expr)
        #    return []

def match_locale_list(extranges, locale):
    if extranges.strip() == '':
        return False
    for extrange in [extrange.strip() for extrange in extranges.split(',')]:
        if match_locale(extrange, locale):
            return True
    return False

def match_locale(extrange, locale):
    # Extended filtering for extended language ranges as
    # defined by RFC4647, part of BCP47.
    # http://tools.ietf.org/html/rfc4647#section-3.3.2
    rangelist = [x.lower() for x in extrange.split('-')]
    localelist = [x.lower() for x in locale.split('-')]
    if rangelist[0] not in ('*', localelist[0]):
        return False
    rangei = localei = 0
    while rangei < len(rangelist):
        if rangelist[rangei] == '*':
            rangei += 1
            continue
        if localei >= len(localelist):
            return False
        if rangelist[rangei] in ('*', localelist[localei]):
            rangei += 1
            localei += 1
            continue
        if len(localelist[localei]) == 1:
            return False
        localei += 1
    return True

_locale_pattern = re.compile('([a-zA-Z0-9-]+)(_[A-Za-z0-9]+)?(@[A-Za-z0-9]+)?(\.[A-Za-z0-9]+)?')
def convert_locale (locale):
    # Automatically convert POSIX-style locales to BCP47
    match = _locale_pattern.match(locale)
    if match is None:
        return locale
    ret = match.group(1).lower()
    variant = match.group(3)
    if variant == '@cyrillic':
        ret += '-Cyrl'
        variant = None
    if variant == '@devanagari':
        ret += '-Deva'
        variant = None
    elif variant == '@latin':
        ret += '-Latn'
        variant = None
    elif variant == '@shaw':
        ret += '-Shaw'
        variant = None
    if match.group(2) is not None:
        ret += '-' + match.group(2)[1:].upper()
    if variant is not None and variant != '@euro':
        ret += '-' + variant[1:].lower()
    return ret


if __name__ == '__main__':
    options = optparse.OptionParser()
    options.set_usage('\n  itstool [OPTIONS] [XMLFILES]\n' +
                      '  itstool -m <MOFILE> [OPTIONS] [XMLFILES]\n' +
                      '  itstool -j <XMLFILE> [OPTIONS] [MOFILES]')
    options.add_option('-i', '--its',
                       action='append',
                       dest='itsfile',
                       metavar='ITS',
                       help='Load the ITS rules in the file ITS (can specify multiple times)')
    options.add_option('-l', '--lang',
                       dest='lang',
                       default=None,
                       metavar='LANGUAGE',
                       help='Explicitly set the language code for output file')
    options.add_option('-j', '--join',
                       dest='join',
                       metavar='FILE',
                       help='Join multiple MO files with the XML file FILE and output XML file')
    options.add_option('-m', '--merge',
                       dest='merge',
                       metavar='FILE',
                       help='Merge from a PO or MO file FILE and output XML files')
    options.add_option('-n', '--no-builtins',
                       action='store_true',
                       dest='nobuiltins',
                       default=False,
                       help='Do not apply the built-in ITS rules')
    options.add_option('-o', '--output',
                       dest='output',
                       default=None,
                       metavar='OUT',
                       help='Output PO files to file OUT or XML files in directory OUT')
    options.add_option('--path',
                       action='append',
                       dest='itspath',
                       default=None,
                       metavar='PATHS',
                       help='Extra path where ITS files may be found (can specify multiple times)')
    options.add_option('-s', '--strict',
                       action='store_true',
                       dest='strict',
                       default=False,
                       help='Exit with error when PO files contain broken XML')
    options.add_option('-d', '--load-dtd',
                       action='store_true',
                       dest='load_dtd',
                       default=False,
                       help='Load external DTDs used by input XML')
    options.add_option('-k', '--keep-entities',
                       action='store_true',
                       dest='keep_entities',
                       default=False,
                       help='Keep entity reference unexpanded')
    options.add_option('-p', '--param',
                       action='append',
                       dest='params',
                       default=[],
                       nargs=2,
                       metavar='NAME VALUE',
                       help='Define the ITS parameter NAME to the value VALUE (can specify multiple times)')
    options.add_option('-t', '--test',
                       dest='test',
                       default=None,
                       metavar='CATEGORY',
                       help='Generate conformance test output for CATEGORY')
    options.add_option('-v', '--version',
                       action='store_true',
                       dest='version',
                       default=False,
                       help='Print itstool version and exit')
    (opts, args) = options.parse_args(sys.argv)

    if opts.version:
        print('itstool %s' % VERSION)
        sys.exit(0)

    params = {}
    for name, value in opts.params:
        params[name] = value

    if opts.merge is None and opts.join is None:
        messages = MessageList()
        for filename in args[1:]:
            doc = Document(filename, messages, load_dtd=opts.load_dtd, keep_entities=opts.keep_entities)
            doc.apply_its_rules(not(opts.nobuiltins), params=params)
            if opts.itsfile is not None:
                for itsfile in opts.itsfile:
                    doc.apply_its_file(itsfile, params=params)
            if opts.test is None:
                doc.generate_messages()
        if opts.output is None or opts.output == '-':
            out = sys.stdout
        else:
            try:
                out = file(opts.output, 'w')
            except:
                sys.stderr.write('Error: Cannot write to file %s\n' % opts.output)
                sys.exit(1)
        if opts.test is not None:
            doc.output_test_data(opts.test, out)
        else:
            messages.output(out)
    elif opts.merge is not None:
        try:
            translations = gettext.GNUTranslations(open(opts.merge, 'rb'))
        except:
            sys.stderr.write('Error: cannot open mo file %s\n' % opts.merge)
            sys.exit(1)
        translations.add_fallback(NoneTranslations())
        if opts.lang is None:
            opts.lang = convert_locale(os.path.splitext(os.path.basename(opts.merge))[0])
        if opts.output is None:
            out = './'
        elif os.path.isdir(opts.output):
            out = opts.output
        elif len(args) == 2:
            if opts.output == '-':
                out = sys.stdout
            else:
                out = file(opts.output, 'w')
        else:
            sys.stderr.write('Error: Non-directory output for multiple files\n')
            sys.exit(1)
        for filename in args[1:]:
            messages = MessageList()
            doc = Document(filename, messages, load_dtd=opts.load_dtd, keep_entities=opts.keep_entities)
            doc.apply_its_rules(not(opts.nobuiltins), params=params)
            if opts.itsfile is not None:
                for itsfile in opts.itsfile:
                    doc.apply_its_file(itsfile, params=params)
            try:
                doc.merge_translations(translations, opts.lang, strict=opts.strict)
            except Exception as e:
                sys.stderr.write('Error: Could not merge translations:\n%s\n' % str(e))
                sys.exit(1)
            fout = out
            if isinstance(fout, basestring):
                fout = file(os.path.join(fout, os.path.basename(filename)), 'w')
            doc.write(fout)
    elif opts.join is not None:
        translations = {}
        for filename in args[1:]:
            try:
                thistr = gettext.GNUTranslations(open(filename, 'rb'))
            except:
                sys.stderr.write('Error: cannot open mo file %s\n' % filename)
                sys.exit(1)
            thistr.add_fallback(NoneTranslations())
            lang = convert_locale(os.path.splitext(os.path.basename(filename))[0])
            translations[lang] = thistr
        if opts.output is None:
            out = sys.stdout
        elif os.path.isdir(opts.output):
            out = file(os.path.join(opts.output, os.path.basename(filename)), 'w')
        else:
            out = file(opts.output, 'w')
        messages = MessageList()
        doc = Document(opts.join, messages)
        doc.apply_its_rules(not(opts.nobuiltins), params=params)
        doc.join_translations(translations, strict=opts.strict)
        doc.write(out)
        if False:
            if opts.itsfile is not None:
                for itsfile in opts.itsfile:
                    doc.apply_its_file(itsfile, params=params)
            try:
                doc.merge_translations(translations, opts.lang, strict=opts.strict)
            except Exception as e:
                sys.stderr.write('Error: Could not merge translations:\n%s\n' % str(e))
                sys.exit(1)
            fout = out
            if isinstance(fout, basestring):
                fout = file(os.path.join(fout, os.path.basename(filename)), 'w')
            fout.write(doc._doc.serialize('utf-8'))
